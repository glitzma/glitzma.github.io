<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Weex SDK Android 源码解析 | 马明娟</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="This is my blog">
    
    <link rel="preload" href="/assets/css/4.styles.6ec7f786.css" as="style"><link rel="preload" href="/assets/js/app~d0ae3f07.6ec7f786.js" as="script"><link rel="preload" href="/assets/css/5.styles.16db5968.css" as="style"><link rel="preload" href="/assets/js/app~d939e436.16db5968.js" as="script"><link rel="preload" href="/assets/css/styles.6aa89410.css" as="style"><link rel="preload" href="/assets/js/app~678f84af.6aa89410.js" as="script"><link rel="preload" href="/assets/css/7.styles.29863426.css" as="style"><link rel="preload" href="/assets/js/7.29863426.js" as="script"><link rel="preload" href="/assets/css/6.styles.e512bc3f.css" as="style"><link rel="preload" href="/assets/js/6.e512bc3f.js" as="script"><link rel="preload" href="/assets/js/20.9f7f1343.js" as="script"><link rel="preload" href="/assets/css/9.styles.8ea75e91.css" as="style"><link rel="preload" href="/assets/js/9.8ea75e91.js" as="script"><link rel="preload" href="/assets/js/65.000c19bb.js" as="script"><link rel="preload" href="/assets/css/8.styles.5f257618.css" as="style"><link rel="preload" href="/assets/js/8.5f257618.js" as="script"><link rel="prefetch" href="/assets/css/0.styles.0ceb5630.css"><link rel="prefetch" href="/assets/css/1.styles.28e1a98a.css"><link rel="prefetch" href="/assets/css/10.styles.53ba72d6.css"><link rel="prefetch" href="/assets/css/11.styles.ffe68642.css"><link rel="prefetch" href="/assets/css/2.styles.140d81ad.css"><link rel="prefetch" href="/assets/js/0.0ceb5630.js"><link rel="prefetch" href="/assets/js/1.28e1a98a.js"><link rel="prefetch" href="/assets/js/10.53ba72d6.js"><link rel="prefetch" href="/assets/js/100.f7435443.js"><link rel="prefetch" href="/assets/js/101.9c6341c0.js"><link rel="prefetch" href="/assets/js/102.8bc49653.js"><link rel="prefetch" href="/assets/js/103.735f85e9.js"><link rel="prefetch" href="/assets/js/104.016ad2f7.js"><link rel="prefetch" href="/assets/js/105.5c755673.js"><link rel="prefetch" href="/assets/js/106.b9a11482.js"><link rel="prefetch" href="/assets/js/107.4f9962ff.js"><link rel="prefetch" href="/assets/js/108.65c9c60c.js"><link rel="prefetch" href="/assets/js/109.87ed92d7.js"><link rel="prefetch" href="/assets/js/11.ffe68642.js"><link rel="prefetch" href="/assets/js/110.e3afa5ab.js"><link rel="prefetch" href="/assets/js/111.f52bbe92.js"><link rel="prefetch" href="/assets/js/112.a83f73b2.js"><link rel="prefetch" href="/assets/js/113.91b00a83.js"><link rel="prefetch" href="/assets/js/114.95289b1b.js"><link rel="prefetch" href="/assets/js/115.12c112f2.js"><link rel="prefetch" href="/assets/js/116.0602548c.js"><link rel="prefetch" href="/assets/js/117.998f3e09.js"><link rel="prefetch" href="/assets/js/118.4289ac42.js"><link rel="prefetch" href="/assets/js/119.2f976588.js"><link rel="prefetch" href="/assets/js/12.a1d3f316.js"><link rel="prefetch" href="/assets/js/120.52192035.js"><link rel="prefetch" href="/assets/js/121.a17bd68f.js"><link rel="prefetch" href="/assets/js/122.19388f8f.js"><link rel="prefetch" href="/assets/js/123.1fe6c02c.js"><link rel="prefetch" href="/assets/js/124.3549f432.js"><link rel="prefetch" href="/assets/js/125.b4477534.js"><link rel="prefetch" href="/assets/js/126.26dead68.js"><link rel="prefetch" href="/assets/js/127.3163bbdb.js"><link rel="prefetch" href="/assets/js/128.7d9c07a0.js"><link rel="prefetch" href="/assets/js/129.5bed095e.js"><link rel="prefetch" href="/assets/js/13.8905be1b.js"><link rel="prefetch" href="/assets/js/130.e4ac434f.js"><link rel="prefetch" href="/assets/js/131.2ef9b646.js"><link rel="prefetch" href="/assets/js/132.46529b4a.js"><link rel="prefetch" href="/assets/js/133.b58a8f68.js"><link rel="prefetch" href="/assets/js/134.620a1429.js"><link rel="prefetch" href="/assets/js/135.f062acc4.js"><link rel="prefetch" href="/assets/js/136.7640ad59.js"><link rel="prefetch" href="/assets/js/137.3a7f63c9.js"><link rel="prefetch" href="/assets/js/138.ef0fa2bd.js"><link rel="prefetch" href="/assets/js/139.06c00b9d.js"><link rel="prefetch" href="/assets/js/14.26a46ba7.js"><link rel="prefetch" href="/assets/js/140.37155e9c.js"><link rel="prefetch" href="/assets/js/141.b7e1f2e0.js"><link rel="prefetch" href="/assets/js/15.e0bcaa64.js"><link rel="prefetch" href="/assets/js/16.86f39da5.js"><link rel="prefetch" href="/assets/js/17.282155eb.js"><link rel="prefetch" href="/assets/js/18.a2bfe117.js"><link rel="prefetch" href="/assets/js/19.f426f241.js"><link rel="prefetch" href="/assets/js/2.140d81ad.js"><link rel="prefetch" href="/assets/js/21.96b5928f.js"><link rel="prefetch" href="/assets/js/22.6c0ef2ad.js"><link rel="prefetch" href="/assets/js/23.49777fda.js"><link rel="prefetch" href="/assets/js/24.44ff95e3.js"><link rel="prefetch" href="/assets/js/25.c0b82f1d.js"><link rel="prefetch" href="/assets/js/26.aec0add8.js"><link rel="prefetch" href="/assets/js/27.6c6e05aa.js"><link rel="prefetch" href="/assets/js/28.5eb3495e.js"><link rel="prefetch" href="/assets/js/29.c4668692.js"><link rel="prefetch" href="/assets/js/30.5313f9ac.js"><link rel="prefetch" href="/assets/js/31.5ad1d4e9.js"><link rel="prefetch" href="/assets/js/32.6429a20b.js"><link rel="prefetch" href="/assets/js/33.15c4d770.js"><link rel="prefetch" href="/assets/js/34.e6e953a3.js"><link rel="prefetch" href="/assets/js/35.135ba76c.js"><link rel="prefetch" href="/assets/js/36.c9ce57eb.js"><link rel="prefetch" href="/assets/js/37.2f07ba1f.js"><link rel="prefetch" href="/assets/js/38.592f7185.js"><link rel="prefetch" href="/assets/js/39.6495ec21.js"><link rel="prefetch" href="/assets/js/40.70da97fc.js"><link rel="prefetch" href="/assets/js/41.af36c460.js"><link rel="prefetch" href="/assets/js/42.1a42d197.js"><link rel="prefetch" href="/assets/js/43.62033e51.js"><link rel="prefetch" href="/assets/js/44.c3a9bd83.js"><link rel="prefetch" href="/assets/js/45.7a814e38.js"><link rel="prefetch" href="/assets/js/46.2c9dad73.js"><link rel="prefetch" href="/assets/js/47.c1e27250.js"><link rel="prefetch" href="/assets/js/48.5945a192.js"><link rel="prefetch" href="/assets/js/49.71bbc7d4.js"><link rel="prefetch" href="/assets/js/50.eb65d05c.js"><link rel="prefetch" href="/assets/js/51.f79fff07.js"><link rel="prefetch" href="/assets/js/52.4d16859b.js"><link rel="prefetch" href="/assets/js/53.7a710a63.js"><link rel="prefetch" href="/assets/js/54.7629ef9f.js"><link rel="prefetch" href="/assets/js/55.c40641ac.js"><link rel="prefetch" href="/assets/js/56.e32352ba.js"><link rel="prefetch" href="/assets/js/57.a5eec8b4.js"><link rel="prefetch" href="/assets/js/58.3170263f.js"><link rel="prefetch" href="/assets/js/59.11bab028.js"><link rel="prefetch" href="/assets/js/60.8e87bf10.js"><link rel="prefetch" href="/assets/js/61.73fbde2a.js"><link rel="prefetch" href="/assets/js/62.091e8107.js"><link rel="prefetch" href="/assets/js/63.c1cc1ab7.js"><link rel="prefetch" href="/assets/js/64.69493e3c.js"><link rel="prefetch" href="/assets/js/66.ee8f46cf.js"><link rel="prefetch" href="/assets/js/67.95154de4.js"><link rel="prefetch" href="/assets/js/68.31ac0d37.js"><link rel="prefetch" href="/assets/js/69.271b3b5e.js"><link rel="prefetch" href="/assets/js/70.80140693.js"><link rel="prefetch" href="/assets/js/71.2e9ff29d.js"><link rel="prefetch" href="/assets/js/72.b726c033.js"><link rel="prefetch" href="/assets/js/73.6a1fe088.js"><link rel="prefetch" href="/assets/js/74.5907410c.js"><link rel="prefetch" href="/assets/js/75.53455465.js"><link rel="prefetch" href="/assets/js/76.f96d8564.js"><link rel="prefetch" href="/assets/js/77.144a123c.js"><link rel="prefetch" href="/assets/js/78.fce2df8e.js"><link rel="prefetch" href="/assets/js/79.c93751f8.js"><link rel="prefetch" href="/assets/js/80.6988b937.js"><link rel="prefetch" href="/assets/js/81.1c31c1dd.js"><link rel="prefetch" href="/assets/js/82.81dd1020.js"><link rel="prefetch" href="/assets/js/83.3500b46f.js"><link rel="prefetch" href="/assets/js/84.564fe023.js"><link rel="prefetch" href="/assets/js/85.4cf6f2df.js"><link rel="prefetch" href="/assets/js/86.2358991d.js"><link rel="prefetch" href="/assets/js/87.c22540c3.js"><link rel="prefetch" href="/assets/js/88.6f59d7e5.js"><link rel="prefetch" href="/assets/js/89.43d101c8.js"><link rel="prefetch" href="/assets/js/90.c303d312.js"><link rel="prefetch" href="/assets/js/91.5de0ca29.js"><link rel="prefetch" href="/assets/js/92.ec835811.js"><link rel="prefetch" href="/assets/js/93.be01a188.js"><link rel="prefetch" href="/assets/js/94.a761544f.js"><link rel="prefetch" href="/assets/js/95.490b1966.js"><link rel="prefetch" href="/assets/js/96.9c2fb30b.js"><link rel="prefetch" href="/assets/js/97.ab9694b3.js"><link rel="prefetch" href="/assets/js/98.794c01ca.js"><link rel="prefetch" href="/assets/js/99.72dbc2a5.js">
    <link rel="stylesheet" href="/assets/css/4.styles.6ec7f786.css"><link rel="stylesheet" href="/assets/css/5.styles.16db5968.css"><link rel="stylesheet" href="/assets/css/styles.6aa89410.css"><link rel="stylesheet" href="/assets/css/7.styles.29863426.css"><link rel="stylesheet" href="/assets/css/6.styles.e512bc3f.css"><link rel="stylesheet" href="/assets/css/9.styles.8ea75e91.css"><link rel="stylesheet" href="/assets/css/8.styles.5f257618.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div id="vuepress-theme-glitzma"><header class="header" style="background-size:cover;background-repeat:no-repeat;background-position:center;background-attachment:scroll;background-image:url(/assets/img/header-image-01.jpg);" data-v-e4a0ebe0><div data-v-6654f004 data-v-e4a0ebe0><nav class="navbar" data-v-6654f004><div class="container" data-v-6654f004><a href="/" class="router-link-active" data-v-6654f004><span class="navbar-site-name" data-v-6654f004>
          马明娟
        </span></a> <div class="navbar-toggler" data-v-6654f004><svg class="icon" style="font-size:1.2em;" data-v-6654f004 data-v-6654f004><title data-v-6654f004 data-v-6654f004>menu</title><use xlink:href="#icon-menu" data-v-6654f004 data-v-6654f004></use></svg></div> <div class="navbar-links" data-v-6654f004><a href="/" class="navbar-link" data-v-6654f004>
            欢迎页
          </a><a href="/posts/" class="navbar-link router-link-active" data-v-6654f004>
            帖子
          </a><a href="/custom-pages/" class="navbar-link" data-v-6654f004>
            关于
          </a></div></div></nav> <div class="navbar-holder" style="display:none;" data-v-6654f004></div></div> <div class="banner" data-v-e2d7da12 data-v-e4a0ebe0 data-v-e4a0ebe0><div class="container" data-v-e2d7da12><div class="center" data-v-e2d7da12></div></div></div></header> <div class="container clearfix show-aside" data-v-0874e876 data-v-0874e876><main class="main" data-v-0874e876><div class="post" data-v-0874e876 data-v-0874e876><section class="post-meta main-div" data-v-7f7ca342><section class="post-date clearfix" data-v-7f7ca342><span class="create-date" data-v-7f7ca342>
      发布时间 : 2017-09-28
    </span> <span class="update-date" data-v-7f7ca342>
      最后修改 : 2021-07-19
    </span></section> <section class="post-links" data-v-7f7ca342><a href="/posts/2017/06/15/css-summary.html" class="post-link" data-v-7f7ca342>
      上一篇 : css遇到问题
    </a> <a href="/posts/2017/11/12/react-learn.html" class="post-link" data-v-7f7ca342>
      下一篇 : react学习
    </a></section></section> <article class="main-div"><div class="post-content content__default"><h2 id="weex-sdk-android-源码解析">Weex SDK Android 源码解析</h2> <p>Weex 是一套构建高性能、可扩展的原生应用跨平台开发方案。一次编写，多端运行。对于前端是个与客户端融合的最方便的路径，透过客户端的模块封装可以快速的让前端突破浏览器的限制，将客户端能力发威到极限，因此除了业务层的深入外，对于 SDK 框架本身也必须更进一步的了解。
本篇主要是从分析代码入手，探讨一下Weex在安卓平台上是如何构建一套JS的运行框架。主要讨论的范畴包括：线程模型、渲染流程、Component/Module的注册流程以及 Weex 中 JNI 的调试技巧。
本文目录结构如下：</p> <div class="language- extra-class"><pre class="language-text"><code>------1. 整体架构
------------1.1 线程模型
----------------1.1.1 结构图
----------------1.1.2 线程间通信
----------------1.1.3 线程异常处理
----------------1.1.4 线程清理
----------------1.1.5 @JSMethod 的使用
------------1.2 渲染模型
----------------1.2.1 结构图
----------------1.2.2 Native 中布局方式
----------------1.2.3 FlexBox 概念说明
----------------1.2.4 CSSNode/WXDomObject 方法说明
----------------1.2.5 ViewPort的使用
------------1.3 Component/Module 注册流程
----------------1.3.1 结构图
----------------1.3.2 Component 注册及使用方式
----------------1.3.3 Module 注册及使用方式
----------------1.3.4 DomObject 注册及使用方式
------2. jni 调试技巧
</code></pre></div><h4 id="整体架构">整体架构</h4> <p>整个运行框架包括三大部分：<code>JS Bridge、Render、Dom</code>，这三大部分都包含在 WXSDKManager 中。WXBridgeManager、WXRenderManager、WXDomManager 都可以通过WXSDKManager 获取。</p> <ol><li><code>JS Bridge</code>：主要用来和 <code>JS Engine（V8）</code>进行双向通信，运行在<code>JSBridge</code>线程中。Weex 的初始化，Component、Module、DomObject的注册与调用，JSBridge 线程管理最终都会由<code>JS Bridge</code> 的管理类 <code>WXBridgeManager</code> 完成。所有和 Dom 相关的操作都会通知到 Dom 线程，交由 <code>WXDomModule</code> 处理。</li> <li>Render：主要用来操作具体的<code>Native View</code>，包括管理Native View的各种操作（添加／删除Component，构造Component Tree等）、Native View的布局等，运行在UI线程中。由 WXRenderManager 统一管理，具体操作由 WXRenderStatement 管理，每一个weex instance 一一对应一个 WXRenderStatement。WXRenderStatement 具体就是操作 WXComponent。</li> <li>Dom：主要用来操作Dom结构，包括生成对应的Dom Tree，添加／删除Dom 节点（WXDomObject）等操作，运行在独立的 Dom 线程中。由 WXDomManager 统一管理，具体操作由 WXDomStatement 管理，每一个weex instance 一一对应一个 WXDomStatement。WXDomStatement 具体就是操作 WXDomObject。所有的 Dom 操作（包括CSSLayout的计算）都在 Dom 线程中，完成后会通知UI线程处理对应的Native Component View。</li></ol> <h4 id="线程模型">线程模型</h4> <p>在处理复杂逻辑的情况下，使用线程是必不可少的，使UI线程不会积压太重的任务，导致界面卡顿。这时候又遇到另一个问题，线程是一次性的消耗品，使用完了线程就自动退出销毁了，假如有比较多的耗时任务，不得不重新创建线程去执行该耗时任务，就会存在性能问题：多次创建和销毁线程是很耗系统资源的。为了解这种问题，我们可以自己构建一个循环线程<code>Looper Thread</code>，当有耗时任务投放到该循环线程中时，线程执行耗时任务，执行完之后循环线程处于等待状态，直到下一个新的耗时任务被投放进来。这样一来就避免了多次创建Thread线程导致的性能问题了。<code>Android SDK</code>中其实已经有一个循环线程的框架-<code>HandlerThread，Weex</code> 中的线程使用的正是<code>HandlerThread</code>，如何使用<code>HandlerThread</code>可以参看官方文档。</p> <h4 id="weex中的线程">Weex中的线程：</h4> <ol><li><code>JSBridgeThread</code>：用来<code>java jni</code>层和v8 engine之间进行通信，包括初始化<code>js framework</code>、<code>callJS</code>、callNative等。</li> <li>DomThread：用来进行Dom操作，包括Dom解析、设置Dom样式、<code>CSS Layout</code>操作、生成Component Tree等操作。图中可知 DomThread 中的操作都是v8 engine调用上来的，也就是说是js runtime生成dom的各种操作，一旦js bundle过大，会是一个瓶颈。</li> <li><code>UIThread</code>：用来真正的视图渲染，包括设置View Layout、设置View Padding、绑定数据、Add/Remove View等操作。</li></ol> <h4 id="通信">通信：</h4> <ol><li>通信方式：三个线程之间的通信方式使用的都是正常的Android Handler通信机制，每个线程中的所有操作都是时序性的（也是Handle的机制决定），保证了操作Dom的时序性。
○ 使用 runnable 方式
Message m = Message.obtain(mJSHandler, WXThread.secure(r));m.obj = token;m.sendToTarget();
○ 使用 handleMessage 方式
Message msg = Message.obtain();WXDomTask task = new WXDomTask();…msg.what = WXDomHandler.MsgType.WX_DOM_CREATE_BODY;msg.obj = task;WXSDKManager.getInstance().getWXDomManager().sendMessage(msg);</li> <li>通信流程
○ UIThread 与 <code>JSBridgeThread</code>： JSBridgeThread 不会直接发送任务给 UIThread ， UIThread 发送给 <code>JSBridgeThread</code> 的任务有初始化<code>js</code> framework、开始渲染页面createInstance、发送event事件等。
○ UIThread 与 DomThread： UIThread 会在销毁instance的时候发送任务给 DomThread 进行清理，DomThread 发送任务给 UIThread 会分为两步，这两步会是一个task：
i. 发送前会重新计算CSSLayout的耗时操作，这部分的操作是在DomThread中进行。
ii. 发送 runnable 到 UIThread，runnable执行的就是view的渲染流程，在UIThread中进行。
说明： 这一整个task是每隔16ms自动触发，也是说一旦dom操作过多，就会拖累帧率。
○ JSBridgeThread 与 DomThread：DomThread不会直接发送任务给JSBridgeThread 。js runtime会通过jni发送指令到 java 层，这一部分在JSBridgeThread中，然后JSBridgeThread会发送任务给 DomThread 进行各种 Dom 操作。</li></ol> <h4 id="线程异常">线程异常</h4> <p>在Weex中线程处理有一个专门的类WXThread，里面分装了HandlerThread处理任务的两种方式：SafeRunnable、SafeCallback，并且 try catch 了所有的异常，以保证在处理过程中异常crash。</p> <h4 id="线程清理">线程清理</h4> <p>正常情况下页面退出，是不是应该把所有的线程清理（quit）呢？weex中的做法是NO，想必是为了提高创建、销毁线程消耗系统资源的效率。Weex中WXSDKManager 、WXBridgeManager是单例，WXRenderManager 、WXDomManager的获取都是通过WXSDKManager，在WXSDKInstance destroy 的时候并不会销毁单实例，因此在多次Weex页面进出的时候线程是重用的。</p> <h4 id="jsmethod">@JSMethod</h4> <p>在WXComponent、WXModule中可以使用 @JSMethod 注解来提供Native方法给JS调用，这个注解有uiThread这个方法，默认值为true 参数说明： 1. 如果uiThread = true，则在UIThread中执行 2. 否则在JSBridgeThread中执行</p> <h4 id="总结">总结</h4> <ol><li>虽说使用了线程，其实都是线性的在执行，只不过把繁重的任务让线程执行了，这也和js runtime中dom解析逻辑、顺序有关。</li> <li>看完了Weex中的线程模型，是不是还是很简单的，没有那么复杂，有木有～</li></ol> <h4 id="渲染">渲染</h4> <p>以添加dom节点来说明整个渲染过程，步骤1可以换成其他dom操作，比如update、remove等操作。步骤2则是通用的。</p> <div class="language- extra-class"><pre class="language-text"><code>1. createBody/addDom： WXDomStatement，从 dom tree 到 component tree 的映射
    ○ WXDomObject.parse() 递归解析dom JSONObject，最终得到当前dom树结构
        i. 实例化WXDomObject
        ii. 设置viewport
        iii. 解析dom JSONObject，得到type、ref、style、attr、event
{    &quot;attr&quot;:{&quot;spmId&quot;:&quot;spma&quot;},    &quot;ref&quot;:&quot;_root&quot;,    &quot;style&quot;:{},    &quot;type&quot;:&quot;div&quot;}
        iv. 赋值 domObject.mDomContext = sdkInstance
    ○ 若为 root 节点
        ■ prepareRoot
            ● 若没有设置style flexDirection 与 backgroundColor，则设置默认值 column、#ffffff
            ● 设置style defaultWidth、defaultHeight
    ○ 普通节点：parent.add(domObject) 把当前解析得到的dom树加到父节点，并且把当前节点和父节点置为 dirty。
    ○ traverseTree 遍历当前dom节点
        ■ 注册得到所有dom节点到 mRegistry 中，标记为 young
        ■ 检查root节点是否为fixed节点，把fixed的节点存到root dom object 内
        ■ apply所有的 style 到 CSSNode
    ○ 递归创建Component Tree
    ○ 添加 createBody 或者 addDom 任务到 renderTask中
    ○ 代码如下：
private void addDomInternal(JSONObject dom,boolean isRoot, String parentRef, final int index){    ……    //only non-root has parent.    WXDomObject parent;    WXDomObject domObject = WXDomObject.parse(dom,instance);    ……    if (isRoot) {      WXDomObject.prepareRoot(domObject, WXViewUtils.getWebPxByWidth(WXViewUtils.getWeexHeight(mInstanceId),WXSDKManager.getInstanceViewPortWidth(mInstanceId)), WXViewUtils.getWebPxByWidth(WXViewUtils.getWeexWidth(mInstanceId),WXSDKManager.getInstanceViewPortWidth(mInstanceId)));    } else if ((parent = mRegistry.get(parentRef)) == null) {      instance.commitUTStab(IWXUserTrackAdapter.DOM_MODULE, errCode);      return;    } else {      //non-root and parent exist      parent.add(domObject, index);    }    domObject.traverseTree( mAddDOMConsumer, ApplyStyleConsumer.getInstance());    //Create component in dom thread    WXComponent component = isRoot ?                        mWXRenderManager.createBodyOnDomThread(mInstanceId, domObject) :                        mWXRenderManager.createComponentOnDomThread(mInstanceId, domObject, parentRef, index);    ……    AddDomInfo addDomInfo = new AddDomInfo();    addDomInfo.component = component;    mAddDom.put(domObject.getRef(), addDomInfo);    IWXRenderTask task = isRoot ? new CreateBodyTask(component) : new AddDOMTask(component, parentRef, index);    mNormalTasks.add(task);    addAnimationForDomTree(domObject);    mDirty = true;    …… }
2. layout：WXDomStatement，由 batch 驱动（每隔16ms执行一批任务，开始渲染）
    ○ 把所有fixed的节点移到 root 节点 child 内
    ○ CSSLayout 计算整个 dom 树（calculateLayout），耗时操作，dom 树即为mRegistry中注册的所有节点
    ○ 遍历 mRegistry 中所有节点
        i. 设置 markLayoutSeen
        ii. applyUpdate：如果当前节点已经被消费，则post message到渲染的 UIThread 更新Component hostView 的 LayoutParams（更新上一帧已经被消费过的节点的LayoutParams）。
为什么需要这个步骤？正常情况下在renderTask中对Component View setLayout就可以了，但是这要基于一个前提，那就是所有的 Dom 节点都已经被注册到 mRegistry 中了，只有这样最后 CSSLayout 计算出来的才是正确的。 由于 batch 驱动的不确定性（有可能分好几帧），非常有可能在本次 Layout 过程中 Dom 数量是不完整的，导致 CSSLayout 计算的结果肯定是不完整的。因此需要每次batch 重新计算完整 dom 树的时候把之前节点 Layout 再更新一遍，并且此时的节点必为 old（上一帧被标为old）
    ○ 更新 mRegistry 中计算好的所有节点到Component Tree中的 Dom 节点，并且置为 old，下次 layout 时需要更新Component 的 LayoutParams。（如果只有一帧，就没有也不需要下次更新的机会了）
    ○ 执行renderTasks：由一系列 `js` bridge 传过来的各种指令，包括Dom操作（createBody、addDom、updateStyle等）、createFinish、updateFinish事件等引起的执行dom对应的componet view操作，这些操作都会被添加到renderTasks中，并且这些任务由 batch 驱动。因为对应的是UI操作，都需在UIThread中执行。
        ■ 示例：createBody、addDom
            ● createView 如果有parent则add到父View
            ● applyLayoutAndEvent：Component setLayout，更新Component hostView 的LayoutParams。
            ● bindData
    ○ 代码如下：
//WXDomStatement.javavoid layout(WXDomObject rootDom) {    ……    rebuildingFixedDomTree(rootDom);    rootDom.calculateLayout(mLayoutContext);    ……    rootDom.traverseTree(new ApplyUpdateConsumer());    updateDomObj();    parseAnimation();    int count = mNormalTasks.size();    for (int i = 0; i &lt; count &amp;&amp; !mDestroy; ++i) {      mWXRenderManager.runOnThread(mInstanceId, mNormalTasks.get(i));    }    mNormalTasks.clear();    mAddDom.clear();    animations.clear();    mDirty = false;    …… }
3. 最终生成的root component 会被添加到 RenderContainer
</code></pre></div><h4 id="布局方式">布局方式：</h4> <p>最终进行布局都会进入函数 applyLayoutAndEvent，layout操作会有两步：</p> <ol><li>setLayout：设置当前view的宽、高，以及 margin 值
○ width：getLayoutWidth() CSSLayout 计算得到的宽
○ height：getLayoutHeight() CSSLayout 计算得到的高
○ left：margin left，当前节点相对于父节点的X坐标 - parent的padding值（包括bording值）
○ top：margin top，同 left 计算方式
○ right：margin right，直接使用CSSLayout计算得到的值
○ bottom：margin bottom，同right 计算方式</li> <li>setPadding：使用 CSSLayout 计算得到的 padding 值设置当前 view 的 padding 值
其实布局就是设置当前 View LayoutParams 的padding、margin值</li></ol> <h4 id="flexbox-概念说明">FlexBox 概念说明</h4> <p>● Flex direction：FlexDirection 控制 children 的排布方向，并且这个属性标实为主轴方向，有四个可选值：
○ Column（默认）：主轴方向从上到下排布，垂直的轴即为从左到右
○ Row：主轴方向从左到右排布，垂直的轴即为从上到下
○ ColumnReverse：和 Column 相反，在 RTL 布局下使用
○ RowReverse：和 Row 相反，在 RTL 布局下使用
● Justify content：JustifyContent 控制在一个容器内主轴方向上 children 的排列方式，比如当 FlexDirection = Row 时，可以用这个属性控制 children 水平居中。有五个可选值：
○ JustifyContent = FlexStart （默认）
○ JustifyContent = FlexEnd
○ JustifyContent = Center
○ JustifyContent = SpaceBetween
○ JustifyContent = SpaceAround
● Flex wrap：FlexWrap 控制容器内的 children 超出容器时的排布方式。有两个可选值：
○ FlexWrap = Nowrap：
○ FlexWrap = Wrap：如果FlexDirection = Row 时则往下排放，如果FlexDirection = Column时则往右排放。
● Alignment：AlignItems 控制在一个容器内垂直轴上 children 的排列方式。和 JustifyContent 有点类似，但是方向上正好相反。有四个可选值：
○ Stretch（默认）：在垂直轴上拉升 children 的大小与容器匹配。
○ FlexStart：排列在垂直轴上的开始位置
○ FlexEnd：排列在垂直轴上的末尾位置
○ Center：排列在垂直轴上的中间位置
● Flex：FlexGrow 控制在主轴上 children 在剩余的空间如何被分布。
○ FlexGrow = 1
● Margin、Padding、Border：Margin 与 Padding 有点类似，但是又有比较大的区别。Margin 相对于父节点或者兄弟节点的边距，而 Padding则是指父容器内 children 的边距。Border 则和 Padding 概念基本一致，主要是用来区别 border 效果的大小。
○ MarginStart = 50
○ MarginEnd = 50
○ MarginAll = 50
○ PaddingAll = 50
○ BorderWidth = 50</p> <h4 id="wxdomobject-cssnode-方法说明">WXDomObject/CSSNode 方法说明</h4> <ol><li>young：标实当前节点是否被消费过，并且只有在第一次注册是标记为 young。消费过即此节点 CSSLayout 计算完成，并且更新到Component中的DomObject，此后此节点必为 old</li> <li>needUpdate：是否需要更新</li> <li>markHasNewLayout：每次 CSSLayout 计算完成，都会标实 LayoutState 为 LayoutState.HAS_NEW_LAYOUT</li> <li>markLayoutSeen：每次 CSSLayout 计算完成之后都要调用这个方法，用来标实当前节点的 CSSLayout 值可以被使用了。如何当前节点没有调用 markLayoutSeen 被 dirty，会抛异常，说明之前的CSSLayout计算还没被使用过。</li> <li>addChild：添加子节点，并且 置为 dirty（自己和父节点）</li> <li>getLayoutX/Y()：相对于父节点的x、y坐标</li> <li>getPadding()：当前节点l、t、r、b的padding距离</li> <li>getBorder()：当前节点l、t、r、b的border距离</li> <li>getMargin()：当前节点l、t、r、b的margin距离</li></ol> <h4 id="viewport">ViewPort</h4> <p>之前框架支持的布局策略是 flexable 布局，在不同屏宽下保持相同 ViewPort（默认 750），整体缩放，可以解决大部分屏幕自适应问题。但是在某些情况下无法满足，比如想让某些元素在不同屏宽手机中都保持相同大小，画一像素的线等。目前weex 支持可配置的响应式布局，自定义设置 ViewPort 值。
使用方式</p> <h4 id="component-module-注册流程">Component/Module 注册流程</h4> <p>Component 和 Module 是 Weex 中主要的两种与  交互的载体，支持与 <code>js</code> 双向通信。也是 Weex 扩展的两种方式，具体的扩展方式可参考这两篇文章 Weex Android/iOS 扩展指南 ，这篇文章主要介绍 Weex Android Component Module 的注册流程，以及懒加载以提高初始化效率。</p> <h4 id="注册流程">注册流程</h4> <p>注册类型主要有：Component、Module、DomObject，注册入口统一在 WXSDKEngine 中
Component
● 注册方式 入口都是从 WXSDKEngine 开始
//WXSDKEngine.javapublic static boolean registerComponent(String type, Class clazz, boolean appendTree) throws WXException {    return registerComponent(clazz, appendTree,type);  }
最终的注册到 WXComponentRegistry.java
public static boolean registerComponent(final String type, final IFComponentHolder holder, final Map componentInfo) throws WXException {……    WXBridgeManager.getInstance()        .post(new Runnable() {      @Override      public void run() {        try {          Map registerInfo = componentInfo;          if (registerInfo == null){            registerInfo = new HashMap&lt;&gt;();          }          registerInfo.put(&quot;type&quot;,type);          registerInfo.put(&quot;methods&quot;,holder.getMethods());          registerNativeComponent(type, holder);          registerJSComponent(registerInfo);          sComponentInfos.add(registerInfo);        } catch (WXException e) {          WXLogUtils.e(&quot;register component error:&quot;, e);        }      }    });    return true;  }
○ 可以看到注册分为两部分，这两部分都是在 bridge 线程中执行：
i. native 部分注册：记录component 的 type 与 holder 的 map 映射。holder 默认为 SimpleComponentHolder，主要用来：如果不为懒加载（lazyLoad），会提前解析好注解 @WXComponentProp 和 @JSMethod，否则会等到使用的时候才会去解析注解，可以提高 weex 的初始化效率。
ii. <code>js</code> 部分注册：把 component 的 type 、methods 信息注册到 <code>js</code> runtime中，可以看到最终的注册部分在 WXBridgeManager 中
private void invokeRegisterComponents(List
● 使用方式 使用 WXComponentFactory 的 newInstance 方法生成 WXComponent。
public static WXComponent newInstance(WXSDKInstance instance, WXDomObject node, WXVContainer parent) {……    IFComponentHolder holder = WXComponentRegistry.getComponent(node.getType());……    try {      return holder.createInstance(instance, node, parent);    } catch (Exception e) {      WXLogUtils.e(&quot;WXComponentFactory Exception type:[&quot; + node.getType() + &quot;] &quot;, e);    }        return null;  }
通过holder （默认为 SimpleComponentHolder ）的 createInstance 方法生成 WXComponent 实例。
Module
Module 的注册方式与使用方式和 Component 类似，入口从 WXSDKEngine 的方法 registerModule 开始。最终通过 WXModuleManager 注册，也分为 native 与 <code>js</code> 两部分注册，注册的类型会区分是否是全局，如果是全局的则会提前实例化好。
● 使用方式 通过 WXModuleManager 的 callModuleMethod 方法使用 WXModule，调用者都是从 WXBridgeManager 发起（<code>js</code>端发起）。
static Object callModuleMethod(final String instanceId, String moduleStr, String methodStr, JSONArray args) {    ModuleFactory factory = sModuleFactoryMap.get(moduleStr);……    final WXModule wxModule = findModule(instanceId, moduleStr,factory);    if (wxModule == null) {      return null;    }    WXSDKInstance instance = WXSDKManager.getInstance().getSDKInstance(instanceId);    wxModule.mWXSDKInstance = instance;    final Invoker invoker = factory.getMethodInvoker(methodStr);    try {     return instance          .getNativeInvokeHelper()          .invoke(wxModule,invoker,args);    } catch (Exception e) {      WXLogUtils.e(&quot;callModuleMethod &gt;&gt;&gt; invoke module:&quot; + moduleStr + &quot;, method:&quot; + methodStr + &quot; failed. &quot;, e);      return null;    } finally {……    }  }
步骤：
a. 实例化 WXModule，会先从全局的Module中找，未找到则通过 ModuleFactory 的 buildInstance 方法实例化。
b. 调用 WXModule 的方法
DomObject
注册 DomObject主要是为了自定义 WXDomObject 类，默认的 Component 对应的domObject 都为 WXDomObject。
● 注册方式：从 WXSDKEngine 的方法 registerDomObject 开始，最终会从 WXDomRegistry 中注册。
● 获取方式：使用场景是在native端生成dom树的时候
a. 从 WXDomRegistry 中获取 DomObject 的 class。
b. 从 WXDomObjectFactory 的方法 newInstance 实例化WXDomObject</p> <h4 id="jni-调试技巧">jni 调试技巧</h4> <p>Android Weex 中使用的 Javascript 引擎为 google 的 V8 引擎，V8 由 C++ 写，在 C++ 与 Java 之间需要JNI进行桥接，普通的JNI的调试方法只能打log输出，重新 ndk build so 动态库文件，重新跑APK程序，比较繁琐，不能直观的动态debug。有一个好消息是最新的Android Studio支持了Android Native 调试，下面就来介绍下如何在Android Studio中动态调试、断点Weex Native 代码。</p> <ol><li>在 SDK Manager 中的 SDK Tools 安装CMake、LLDB、NDK。</li> <li>在 Weex SDK 项目中的 build.gradle 增加如下配置</li></ol> <div class="language- extra-class"><pre><code>```
android {
    externalNativeBuild {
        ndkBuild {
            path '../../../weex_v8core/jni/Android.mk' // v8core的具体路径
        }
    }
}
```
</code></pre></div><ol start="3"><li>把 v8core 目录下build出来的v8core/obj/local/armeabi/libweexv8.so 拷贝到weex sdk目录libs下对应的文件夹中，这一步尤为关键，这个 so 文件是静态文件，不是动态库文件，里面包含了所有符号，因此可以调试debug。</li></ol></div></article> <section class="post-meta main-div" data-v-7f7ca342><section class="post-date clearfix" data-v-7f7ca342><span class="create-date" data-v-7f7ca342>
      发布时间 : 2017-09-28
    </span> <span class="update-date" data-v-7f7ca342>
      最后修改 : 2021-07-19
    </span></section> <section class="post-links" data-v-7f7ca342><a href="/posts/2017/06/15/css-summary.html" class="post-link" data-v-7f7ca342>
      上一篇 : css遇到问题
    </a> <a href="/posts/2017/11/12/react-learn.html" class="post-link" data-v-7f7ca342>
      下一篇 : react学习
    </a></section></section> <div id="post-comments" class="main-div"><!----></div></div></main> <aside class="aside" data-v-0874e876><div class="info-card main-div" data-v-2bd66a30 data-v-0874e876><div class="info-card-header" data-v-2bd66a30><img src="https://www.mamingjuan.cn/assets/img/avatar.jpeg" alt="Glitr" class="info-avatar" data-v-2bd66a30></div> <div class="info-card-body" data-v-2bd66a30><section class="info-nickname" data-v-2bd66a30>
      Glitr
    </section> <section class="info-desc" data-v-2bd66a30>Enjoy coding,<br/>Enjoy life:)</section> <section class="info-contact" data-v-2bd66a30><section data-v-2bd66a30><span title="Beijing City, China" data-v-2bd66a30 data-v-2bd66a30><svg class="icon" style="font-size:1em;" data-v-2bd66a30 data-v-2bd66a30><title data-v-2bd66a30 data-v-2bd66a30>Beijing City, China</title><use xlink:href="#icon-location" data-v-2bd66a30 data-v-2bd66a30></use></svg><span class="info-text" data-v-2bd66a30 data-v-2bd66a30>
          Beijing City, China
        </span></span></section> <section data-v-2bd66a30><span title="Secrecy" data-v-2bd66a30 data-v-2bd66a30><svg class="icon" style="font-size:1em;" data-v-2bd66a30 data-v-2bd66a30><title data-v-2bd66a30 data-v-2bd66a30>Secrecy</title><use xlink:href="#icon-organization" data-v-2bd66a30 data-v-2bd66a30></use></svg><span class="info-text" data-v-2bd66a30 data-v-2bd66a30>
          Secrecy
        </span></span></section> <section data-v-2bd66a30><a href="mailto:glitteringma@gmail.com" title="glitteringma@gmail.com" data-v-2bd66a30 data-v-2bd66a30><svg class="icon" style="font-size:1em;" data-v-2bd66a30 data-v-2bd66a30><title data-v-2bd66a30 data-v-2bd66a30>glitteringma@gmail.com</title><use xlink:href="#icon-email" data-v-2bd66a30 data-v-2bd66a30></use></svg><span class="info-text" data-v-2bd66a30 data-v-2bd66a30>
          glitteringma@gmail.com
        </span></a></section></section></div> <div class="info-card-footer" data-v-2bd66a30><section class="info-sns clearfix" data-v-2bd66a30><a href="https://github.com/happy760690" target="_blank" class="sns-link" data-v-2bd66a30><span title="GitHub: glitzma" class="sns-icon" data-v-2bd66a30 data-v-2bd66a30><svg class="icon" style="font-size:1.5em;" data-v-2bd66a30 data-v-2bd66a30><title data-v-2bd66a30 data-v-2bd66a30>GitHub: glitzma</title><use xlink:href="#icon-github" data-v-2bd66a30 data-v-2bd66a30></use></svg></span></a><a href="https://twitter.com/x0BKGuGTNoqZ0F7" target="_blank" class="sns-link" data-v-2bd66a30><span title="Twitter: x0BKGuGTNoqZ0F7" class="sns-icon" data-v-2bd66a30 data-v-2bd66a30><svg class="icon" style="font-size:1.5em;" data-v-2bd66a30 data-v-2bd66a30><title data-v-2bd66a30 data-v-2bd66a30>Twitter: x0BKGuGTNoqZ0F7</title><use xlink:href="#icon-twitter" data-v-2bd66a30 data-v-2bd66a30></use></svg></span></a><a href="https://www.instagram.com/glitz9558/?hl=en" target="_blank" class="sns-link" data-v-2bd66a30><span title="Instagram: glitz9558" class="sns-icon" data-v-2bd66a30 data-v-2bd66a30><svg class="icon" style="font-size:1.5em;" data-v-2bd66a30 data-v-2bd66a30><title data-v-2bd66a30 data-v-2bd66a30>Instagram: glitz9558</title><use xlink:href="#icon-instagram" data-v-2bd66a30 data-v-2bd66a30></use></svg></span></a></section></div></div> <div class="post-nav-card main-div" style="position:relative;top:0;width:0px;" data-v-0874e876><div class="post-nav-contents"><svg class="icon"><title>book</title><use xlink:href="#icon-book"></use></svg> <span>文章目录</span> <div class="post-nav-toc"><ul><li><a href="/posts/2017/09/28/weex-android.html#weex-sdk-android-源码解析">Weex SDK Android 源码解析</a></li></ul></div></div> <div class="post-nav-comments"><svg class="icon"><title>comment</title><use xlink:href="#icon-comment"></use></svg> <a href="/posts/2017/09/28/weex-android.html#post-comments">
      评论
    </a></div></div></aside></div> <footer class="footer" data-v-e361d3ee><p class="sns-links" data-v-e361d3ee><a href="https://github.com/happy760690" target="_blank" class="sns-link" data-v-e361d3ee><span title="GitHub: glitzma" class="sns-icon" data-v-e361d3ee data-v-e361d3ee><svg class="icon" style="font-size:25px;" data-v-e361d3ee data-v-e361d3ee><title data-v-e361d3ee data-v-e361d3ee>GitHub: glitzma</title><use xlink:href="#icon-github" data-v-e361d3ee data-v-e361d3ee></use></svg></span></a><a href="https://twitter.com/x0BKGuGTNoqZ0F7" target="_blank" class="sns-link" data-v-e361d3ee><span title="Twitter: x0BKGuGTNoqZ0F7" class="sns-icon" data-v-e361d3ee data-v-e361d3ee><svg class="icon" style="font-size:25px;" data-v-e361d3ee data-v-e361d3ee><title data-v-e361d3ee data-v-e361d3ee>Twitter: x0BKGuGTNoqZ0F7</title><use xlink:href="#icon-twitter" data-v-e361d3ee data-v-e361d3ee></use></svg></span></a><a href="https://www.instagram.com/glitz9558/?hl=en" target="_blank" class="sns-link" data-v-e361d3ee><span title="Instagram: glitz9558" class="sns-icon" data-v-e361d3ee data-v-e361d3ee><svg class="icon" style="font-size:25px;" data-v-e361d3ee data-v-e361d3ee><title data-v-e361d3ee data-v-e361d3ee>Instagram: glitz9558</title><use xlink:href="#icon-instagram" data-v-e361d3ee data-v-e361d3ee></use></svg></span></a></p> <p data-v-e361d3ee><span data-v-e361d3ee>Powered by </span> <a href="https://vuepress.vuejs.org" target="_blank" data-v-e361d3ee>
      Vuepress
    </a></p></footer></div><div class="global-ui"><!----><!----></div></div>
    <script src="/assets/js/app~d0ae3f07.6ec7f786.js" defer></script><script src="/assets/js/7.29863426.js" defer></script><script src="/assets/js/6.e512bc3f.js" defer></script><script src="/assets/js/20.9f7f1343.js" defer></script><script src="/assets/js/9.8ea75e91.js" defer></script><script src="/assets/js/65.000c19bb.js" defer></script><script src="/assets/js/8.5f257618.js" defer></script><script src="/assets/js/app~d939e436.16db5968.js" defer></script><script src="/assets/js/app~678f84af.6aa89410.js" defer></script>
  </body>
</html>
