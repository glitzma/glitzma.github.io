(window.webpackJsonp=window.webpackJsonp||[]).push([[124],{482:function(t,e,v){"use strict";v.r(e);var a=v(4),_=Object(a.a)({},(function(){var t=this,e=t.$createElement,v=t._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h3",{attrs:{id:"为什么会有vdom"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#为什么会有vdom"}},[t._v("#")]),t._v(" 为什么会有vdom")]),t._v(" "),v("ul",[v("li",[t._v("正常的dom操作非常耗费性能，以前用jQuery操作dom全靠手动调整很费力。容易出错，不易于维护。")]),t._v(" "),v("li",[t._v("当程序有了一定的复杂度，想减少计算次数比较难，用js描述dom节点，计算最小的变更再操作dom性能更高。")]),t._v(" "),v("li",[t._v("数据驱动视图，控制dom操作")])]),t._v(" "),v("h3",{attrs:{id:"diff算法概述"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#diff算法概述"}},[t._v("#")]),t._v(" diff算法概述")]),t._v(" "),v("ul",[v("li",[t._v("diff算法是vdom的核心部分。")]),t._v(" "),v("li",[t._v("diff算法是一个比较广泛的概念，如：linux diff、git diff")]),t._v(" "),v("li",[t._v("两个js对象也可以做diff，两个树也能做diff")]),t._v(" "),v("li",[t._v("vue dom diff主要是同一层级做比较，tag不同则直接删除掉重建，不再深入比较，tag与key相同则认为是相同节点，不再深度比较。")]),t._v(" "),v("li",[t._v("不使用key的dom更新时直接删除重新建，如果使用key可以通过判断key与tag的匹配度来确认保留还是新建")])]),t._v(" "),v("h3",{attrs:{id:"模板编译过程概述"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#模板编译过程概述"}},[t._v("#")]),t._v(" 模板编译过程概述")]),t._v(" "),v("p",[t._v("vue template compiler将模板编译为render函数，执行render 函数生成vnode。基于vnode进行patch和diff。")]),t._v(" "),v("p",[t._v("使用vue-loader在开发环境下编译模板。")]),t._v(" "),v("h3",{attrs:{id:"组件的渲染更新过程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#组件的渲染更新过程"}},[t._v("#")]),t._v(" 组件的渲染更新过程")]),t._v(" "),v("ol",[v("li",[t._v("初次渲染")])]),t._v(" "),v("ul",[v("li",[t._v("解析模板为render函数")]),t._v(" "),v("li",[t._v("触发响应式，通过getter setter 监听data属性")]),t._v(" "),v("li",[t._v("执行render函数，生成vnode， 然后patch（elem,vnode)")])]),t._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[t._v("注")]),t._v(" "),v("p",[t._v("执行render函数会触发getter")])]),t._v(" "),v("ol",{attrs:{start:"2"}},[v("li",[t._v("更新过程")])]),t._v(" "),v("ul",[v("li",[t._v("修改data触发setter（此前已被收集监听的getter）")]),t._v(" "),v("li",[t._v("重新执行render函数，成生newVnode")]),t._v(" "),v("li",[t._v("patch（vnode,newVnode)")])]),t._v(" "),v("p",[t._v("流程图")]),t._v(" "),v("img",{attrs:{width:"70%",src:t.$withBase("/assets/img/update-component.png"),alt:"update-component-process"}}),t._v(" "),v("ol",{attrs:{start:"3"}},[v("li",[t._v("异步渲染")])]),t._v(" "),v("ul",[v("li",[t._v("$nextTick待dom渲染完再回调。")]),t._v(" "),v("li",[t._v("页面渲染时会将data的修改做整合，多次data修改只会渲染一次。")]),t._v(" "),v("li",[t._v("减少dom操作次数，提高性能。")])]),t._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[t._v("注")]),t._v(" "),v("p",[t._v("注： ajax请求要放到mounted中。vue本身不支持ajax请求，需要使用vue-resource、axios等插件实现。一个组件的created比mounted早调用不了几微秒。放到created性能提高不了多少，而且等异步渲染的时候，create可能被中途打断，中断之后渲染又要重做一遍，在created中做ajax调用，代码里只有一次调用，但实际上可能是n次调用。如果将ajax调用放到mounted阶段，不会有重复的调用，更合适。")])]),t._v(" "),v("h3",{attrs:{id:"将props传递子组件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#将props传递子组件"}},[t._v("#")]),t._v(" 将props传递子组件")]),t._v(" "),v("p",[v("code",[t._v('<User v-bind="$Props"/>')])]),t._v(" "),v("p",[t._v("因为在React的的高阶组件用的时候，最好将props全部传递给调用的父组件。所以vue这里也提一下。")]),t._v(" "),v("h3",{attrs:{id:"响应式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#响应式"}},[t._v("#")]),t._v(" 响应式")]),t._v(" "),v("p",[t._v("vue2.x")]),t._v(" "),v("ul",[v("li",[t._v("核心api - object.defineProperty")]),t._v(" "),v("li",[t._v("在监听对象需要深度遍历和监听数组时需要对数组属性做特殊处理，处理数组数据重新定义数组原型触发视图更新")]),t._v(" "),v("li",[t._v("复杂对象的深度监听会有问题，因为处理监听时需要递归到底，一次性计算量大")]),t._v(" "),v("li",[t._v("无法监听新增、删除属性（vue.set、vue.delete）")])]),t._v(" "),v("p",[t._v("vue3")]),t._v(" "),v("ul",[v("li",[t._v("核心api proxy 、reflect")]),t._v(" "),v("li",[t._v("深度监听性能更好")]),t._v(" "),v("li",[t._v("可监听 新增、删除属性")]),t._v(" "),v("li",[t._v("可监听数组变化")]),t._v(" "),v("li",[t._v("proxy可规避object.defineProperty的问题，但proxy无法兼容所有浏览器")])])])}),[],!1,null,null,null);e.default=_.exports}}]);