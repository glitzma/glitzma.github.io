(window.webpackJsonp=window.webpackJsonp||[]).push([[131],{581:function(v,e,t){"use strict";t.r(e);var _=t(25),i=Object(_.a)({},(function(){var v=this,e=v.$createElement,t=v._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h3",{attrs:{id:"为什么会有vdom"}},[v._v("为什么会有vdom")]),v._v(" "),t("ul",[t("li",[v._v("正常的dom操作非常耗费性能，以前用jQuery操作dom全靠手动调整很费力。容易出错，不易于维护。")]),v._v(" "),t("li",[v._v("当程序有了一定的复杂度，想减少计算次数比较难，用js描述dom节点，计算最小的变更再操作dom性能更高。")]),v._v(" "),t("li",[v._v("数据驱动视图，控制dom操作")])]),v._v(" "),t("h3",{attrs:{id:"diff算法概述"}},[v._v("diff算法概述")]),v._v(" "),t("ul",[t("li",[v._v("diff算法是vdom的核心部分。")]),v._v(" "),t("li",[v._v("diff算法是一个比较广泛的概念，如：linux diff、git diff")]),v._v(" "),t("li",[v._v("两个js对象也可以做diff，两个树也能做diff")]),v._v(" "),t("li",[v._v("vue dom diff主要是同一层级做比较，tag不同则直接删除掉重建，不再深入比较，tag与key相同则认为是相同节点，不再深度比较。")]),v._v(" "),t("li",[v._v("不使用key的dom更新时直接删除重新建，如果使用key可以通过判断key与tag的匹配度来确认保留还是新建")])]),v._v(" "),t("h3",{attrs:{id:"模板编译过程概述"}},[v._v("模板编译过程概述")]),v._v(" "),t("p",[v._v("vue template compiler将模板编译为render函数，执行render 函数生成vnode。基于vnode进行patch和diff。")]),v._v(" "),t("p",[v._v("使用vue-loader在开发环境下编译模板。")]),v._v(" "),t("h3",{attrs:{id:"组件的渲染更新过程"}},[v._v("组件的渲染更新过程")]),v._v(" "),t("ol",[t("li",[v._v("初次渲染")])]),v._v(" "),t("ul",[t("li",[v._v("解析模板为render函数")]),v._v(" "),t("li",[v._v("触发响应式，通过getter setter 监听data属性")]),v._v(" "),t("li",[v._v("执行render函数，生成vnode， 然后patch（elem,vnode)")])]),v._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[v._v("注")]),v._v(" "),t("p",[v._v("执行render函数会触发getter")])]),v._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[v._v("更新过程")])]),v._v(" "),t("ul",[t("li",[v._v("修改data触发setter（此前已被收集监听的getter）")]),v._v(" "),t("li",[v._v("重新执行render函数，成生newVnode")]),v._v(" "),t("li",[v._v("patch（vnode,newVnode)")])]),v._v(" "),t("p",[v._v("流程图")]),v._v(" "),t("img",{attrs:{width:"70%",src:v.$withBase("/assets/img/update-component.png"),alt:"update-component-process"}}),v._v(" "),t("ol",{attrs:{start:"3"}},[t("li",[v._v("异步渲染")])]),v._v(" "),t("ul",[t("li",[v._v("$nextTick待dom渲染完再回调。")]),v._v(" "),t("li",[v._v("页面渲染时会将data的修改做整合，多次data修改只会渲染一次。")]),v._v(" "),t("li",[v._v("减少dom操作次数，提高性能。")])]),v._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[v._v("注")]),v._v(" "),t("p",[v._v("注： ajax请求要放到mounted中。vue本身不支持ajax请求，需要使用vue-resource、axios等插件实现。一个组件的created比mounted早调用不了几微秒。放到created性能提高不了多少，而且等异步渲染的时候，create可能被中途打断，中断之后渲染又要重做一遍，在created中做ajax调用，代码里只有一次调用，但实际上可能是n次调用。如果将ajax调用放到mounted阶段，不会有重复的调用，更合适。")])]),v._v(" "),t("h3",{attrs:{id:"将props传递子组件"}},[v._v("将props传递子组件")]),v._v(" "),t("p",[t("code",[v._v('<User v-bind="$Props"/>')])]),v._v(" "),t("p",[v._v("因为在React的的高阶组件用的时候，最好将props全部传递给调用的父组件。所以vue这里也提一下。")]),v._v(" "),t("h3",{attrs:{id:"响应式"}},[v._v("响应式")]),v._v(" "),t("p",[v._v("vue2.x")]),v._v(" "),t("ul",[t("li",[v._v("核心api - object.defineProperty")]),v._v(" "),t("li",[v._v("在监听对象需要深度遍历和监听数组时需要对数组属性做特殊处理，处理数组数据重新定义数组原型触发视图更新")]),v._v(" "),t("li",[v._v("复杂对象的深度监听会有问题，因为处理监听时需要递归到底，一次性计算量大")]),v._v(" "),t("li",[v._v("无法监听新增、删除属性（vue.set、vue.delete）")])]),v._v(" "),t("p",[v._v("vue3")]),v._v(" "),t("ul",[t("li",[v._v("核心api proxy 、reflect")]),v._v(" "),t("li",[v._v("深度监听性能更好")]),v._v(" "),t("li",[v._v("可监听 新增、删除属性")]),v._v(" "),t("li",[v._v("可监听数组变化")]),v._v(" "),t("li",[v._v("proxy可规避object.defineProperty的问题，但proxy无法兼容所有浏览器")])])])}),[],!1,null,null,null);e.default=i.exports}}]);