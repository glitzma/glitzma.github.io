(window.webpackJsonp=window.webpackJsonp||[]).push([[135],{477:function(t,e,a){"use strict";a.r(e);var v=a(4),r=Object(v.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"v8垃圾回收机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#v8垃圾回收机制"}},[t._v("#")]),t._v(" V8垃圾回收机制")]),t._v(" "),a("p",[t._v("概括："),a("br"),t._v("\nv8的垃圾回收机制策略主要是基于分布式垃圾回收机制，其根据对象的存活时间，将内存的垃圾回收进行不同的分代，然后对不同的分代进行不同的垃圾回收算法。"),a("br"),t._v("\nv8内存结构由以下几个部分组成：新生代(new_space)、老生代(old_space)、大对象区(large_object_space)、代码区(code_space)、map区(map_space)")]),t._v(" "),a("h4",{attrs:{id:"新生代"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#新生代"}},[t._v("#")]),t._v(" 新生代：")]),t._v(" "),a("p",[t._v("垃圾回收过程中主要采用了Scavenge算法。在Scavenge算法的具体实现中，主要采用了Cheney算法，它将新生代内存一分为二，一个叫From，一个叫To。当From中某对象没有其它引用时，将其它活跃对象复制到To空间，然后将From中所有非存活对象清除。清空后To与From进行角色互换，再有垃圾数据时重复刚才的做法。")]),t._v(" "),a("h4",{attrs:{id:"对象晋升"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对象晋升"}},[t._v("#")]),t._v(" 对象晋升：")]),t._v(" "),a("p",[t._v("一个对象复制多次后依旧存活，该对象在下一次垃圾回收时直接转移到老生代中，这个过程叫"),a("code",[t._v("晋升")])]),t._v(" "),a("p",[t._v("晋升条件：")]),t._v(" "),a("ul",[a("li",[t._v("对象是否经历过一次Scavenge算法")]),t._v(" "),a("li",[t._v("To空间的内存占比是否已经超过25%")])]),t._v(" "),a("h4",{attrs:{id:"老生代"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#老生代"}},[t._v("#")]),t._v(" 老生代：")]),t._v(" "),a("p",[t._v("在老生代中，因为管理着大量的存活对象，如果依旧使用Scavenge算法的话，很明显会浪费一半的内存，因此已经不再使用Scavenge算法，而是采用新的算法Mark-Sweep(标记清除)和Mark-Compact(标记整理)来进行管理。早前我们听过引用计数的算法，但碰到循环引用时无法被回收。截至2012年所有的现代浏览器均放弃了这种算法，转而采用新的Mark-Sweep(标记清除)和Mark-Compact(标记整理)算法。"),a("br"),t._v("\nMark-Sweep(标记清除)分为标记和清除两个阶段，在标记阶段会遍历堆中的所有对象，然后标记活着的对象，在清除阶段中，会将死亡的对象进行清除。")]),t._v(" "),a("ul",[a("li",[t._v("垃圾回收器会在内部构建一个根列表，用于从根节点出发去寻找那些可以被访问到的变量。比如在JavaScript中，window全局对象可以看成一个根节点。")]),t._v(" "),a("li",[t._v("然后，垃圾回收器从所有根节点出发，遍历其可以访问到的子节点，并将其标记为活动的，根节点不能到达的地方即为非活动的，将会被视为垃圾。")]),t._v(" "),a("li",[t._v("最后，垃圾回收器将会释放所有非活动的内存块，并将其归还给操作系统。")])]),t._v(" "),a("p",[t._v("这种方式会出现内存碎片如果需要很大的空间，但不足以分配时就会提前触发垃圾回收，因此"),a("code",[t._v("Mark-Compact(标记整理)")]),t._v("就出现了。解决方式为将活动对象住内存的一端移动，移动后清理掉边界外的所有内存。"),a("br"),t._v("\n由于JS的单线程机制，垃圾回收的过程会阻碍主线程同步任务的执行，待执行完垃圾回收后才会再次恢复执行主任务的逻辑，这种行为被称为全停顿(stop-the-world)。在标记阶段同样会阻碍主线程的执行，老生代会保存大量存活的对象，如果在标记阶段将整个堆内存遍历一遍，那么势必会造成严重的卡顿。"),a("br"),t._v("\n为了减少卡顿，v8引入了Incremental Marking(增量标记)，先标记内存中的了部分对象，然后将权交给js主线程。当主线程任务执行完后，再从原来标记的地方继续标记，直到标记完整个内存。")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),a("p",[t._v("这个理念其实有点像React框架中的Fiber架构，只有在浏览器的空闲时间才会去遍历Fiber Tree执行对应的任务，否则延迟执行，尽可能少地影响主线程的任务，避免应用卡顿，提升应用性能。")])]),t._v(" "),a("p",[t._v("得益于增量标记的好处，V8引擎后续继续引入了延迟清理(lazy sweeping)和增量式整理(incremental compaction)，让清理和整理的过程也变成增量式的。同时为了充分利用多核CPU的性能，也将引入并行标记和并行清理，进一步地减少垃圾回收对主线程的影响，为应用提升了更多的性能。")]),t._v(" "),a("h4",{attrs:{id:"如何避免内存泄漏"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何避免内存泄漏"}},[t._v("#")]),t._v(" 如何避免内存泄漏")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("当进行垃圾回收时，在标记阶段因为window对象可以作为根节点，在window上挂载的属性均可以被访问到，并将其标记为活动的从而常驻内存，因此也就不会被垃圾回收，只有在整个进程退出时全局作用域才会被销毁。如果你遇到需要必须使用全局变量的场景，那么请保证一定要在全局变量使用完毕后将其设置为null从而触发回收机制。")])]),t._v(" "),a("li",[a("p",[t._v("经常会有使用setTimeout或者setInterval等定时器的场景，定时器本身是一个非常有用的功能，忘记在适当的时间手动清除定时器，那么很有可能就会导致内存泄漏。")])]),t._v(" "),a("li",[a("p",[t._v("少用闭包")])]),t._v(" "),a("li",[a("p",[t._v("我们在操作DOM元素时，为了避免多次获取DOM元素，我们会将DOM元素存储在一个数据字典中。我们手动清除对button元素的引用才会被垃圾回收。")])]),t._v(" "),a("li",[a("p",[t._v("在ES6中为我们新增了两个有效的数据结构WeakMap和WeakSet，就是为了解决内存泄漏的问题而诞生的弱引用")])])]),t._v(" "),a("p",[a("a",{attrs:{href:"https://juejin.cn/post/6844904016325902344",target:"_blank",rel:"noopener noreferrer"}},[t._v("文章地址"),a("OutboundLink")],1)]),t._v(" "),a("h2",{attrs:{id:"event-loop"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#event-loop"}},[t._v("#")]),t._v(" event Loop")]),t._v(" "),a("img",{attrs:{width:"80%",src:t.$withBase("/assets/img/event-loop.jpeg")}}),t._v(" "),a("p",[t._v("这张图将浏览器的Event Loop完整的描述了出来，我来讲执行一个JavaScript代码的具体流程：")]),t._v(" "),a("ol",[a("li",[t._v("执行全局Script同步代码，这些同步代码有一些是同步语句，有一些是异步语句（比如setTimeout等）；")]),t._v(" "),a("li",[t._v("全局Script代码执行完毕后，调用栈Stack会清空；")]),t._v(" "),a("li",[t._v("从微队列microtask queue中取出位于队首的回调任务，放入调用栈Stack中执行，执行完后microtask queue长度减1；")]),t._v(" "),a("li",[t._v("继续取出位于队首的任务，放入调用栈Stack中执行，以此类推，直到直到把microtask queue中的所有任务都执行完毕。注意，如果在执行microtask的过程中，又产生了microtask，那么会加入到队列的末尾，也会在这个周期被调用执行；")]),t._v(" "),a("li",[t._v("microtask queue中的所有任务都执行完毕，此时microtask queue为空队列，调用栈Stack也为空；")]),t._v(" "),a("li",[t._v("取出宏队列macrotask queue中位于队首的任务，放入Stack中执行；")]),t._v(" "),a("li",[t._v("执行完毕后，调用栈Stack为空；")]),t._v(" "),a("li",[t._v("重复第3-7个步骤；")]),t._v(" "),a("li",[t._v("重复第3-7个步骤；")]),t._v(" "),a("li",[t._v("......")])]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("3个重点")]),t._v(" "),a("ol",[a("li",[t._v("宏队列macrotask一次只从队列中取一个任务执行，执行完后就去执行微任务队列中的任务；")]),t._v(" "),a("li",[t._v("微任务队列中所有的任务都会被依次取出来执行，知道microtask queue为空；")]),t._v(" "),a("li",[t._v("图中没有画UI rendering的节点，因为这个是由浏览器自行判断决定的，但是只要执行UI rendering，它的节点是在执行完所有的microtask之后，下一个macrotask之前，紧跟着执行UI render。")])])]),t._v(" "),a("p",[a("a",{attrs:{href:"https://segmentfault.com/a/1190000016278115",target:"_blank",rel:"noopener noreferrer"}},[t._v("参考文章"),a("OutboundLink")],1)])])}),[],!1,null,null,null);e.default=r.exports}}]);