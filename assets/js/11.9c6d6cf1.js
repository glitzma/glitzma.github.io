(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{492:function(_,v,t){_.exports=t.p+"assets/img/lisan.27cc7c7e.jpg"},604:function(_,v,t){"use strict";t.r(v);var i=t(7),l=Object(i.a)({},(function(){var _=this,v=_.$createElement,i=_._self._c||v;return i("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[i("h2",{attrs:{id:"_1-存储问题描述"}},[_._v("1. 存储问题描述")]),_._v(" "),i("p",[_._v("小程序没有数据库，但我们需要实现离线存储。LocalStorage存放大的连续数据时，读写极慢。于是我们选择了离散存储方式，解决性能问题。")]),_._v(" "),i("h3",{attrs:{id:"_1-1-基本存储分配方式"}},[_._v("1.1 基本存储分配方式")]),_._v(" "),i("p",[_._v("存储器的分配方式包括连续存储和离散存储。")]),_._v(" "),i("p",[_._v("连续存储包括单一连续、固定分配、动态分配、可重定位分配-紧凑功能。")]),_._v(" "),i("p",[_._v("离散存储包括页式、段式、段页式")]),_._v(" "),i("h3",{attrs:{id:"_1-2-连续存储"}},[_._v("1.2 连续存储")]),_._v(" "),i("p",[_._v("连续存储管理是把内存中用户区作为一个连续区域或者若干个连续区域进行管理")]),_._v(" "),i("h4",{attrs:{id:"_1-2-1-单一连续存储"}},[_._v("1.2.1 单一连续存储")]),_._v(" "),i("p",[_._v("操作系统占用一部分内存空间，剩下作为一个连续区分配给一个作业使用。")]),_._v(" "),i("p",[_._v("缺点")]),_._v(" "),i("ul",[i("li",[_._v("CPU利用率比较低")]),_._v(" "),i("li",[_._v("内存得不到充分利用")]),_._v(" "),i("li",[_._v("外围设备利用率不高")])]),_._v(" "),i("h4",{attrs:{id:"_1-2-2-固定分配存储"}},[_._v("1.2.2 固定分配存储")]),_._v(" "),i("p",[_._v("把用户区分为若干个连续区域，每一个区域称为一个分区，分区的大小和个数都固定不变，每个分区只能装入一个作业，不允许一个作业跨分区存储。")]),_._v(" "),i("p",[_._v("地址转换和存储保护")]),_._v(" "),i("ul",[i("li",[_._v("地址转换：逻辑地址+分区的下限地址=物理地址")]),_._v(" "),i("li",[_._v("存储保护：判断 - 下限地址≤物理地址≤上限地址")])]),_._v(" "),i("p",[_._v("空间利用率")]),_._v(" "),i("ul",[i("li",[_._v("内存碎片产生原因：为作业分配一个不小于作业地址空间的分区，产生了一部分空闲区域")])]),_._v(" "),i("p",[_._v("改进：")]),_._v(" "),i("ul",[i("li",[_._v("根据经常出现的作业的大小和频率划分分区")]),_._v(" "),i("li",[_._v("按分区大小排列")]),_._v(" "),i("li",[_._v("按作业对内存空间需求量排成多个作业队列，每个作业队列只能装入对应的分区中，不同分区可以同时装入作业，作业不能装入其他作业队列对应的分区只能装入自己对应的分区")])]),_._v(" "),i("h4",{attrs:{id:"_1-2-3-动态分配存储"}},[_._v("1.2.3 动态分配存储")]),_._v(" "),i("p",[_._v("在作业装入内存时，根据作业需要的地址空间的大小和当时的内存使用情况决定是否为该作业分配一个分区，分区的大小和个数随着装入内存作业的装入与撤离而发生变化")]),_._v(" "),i("ul",[i("li",[_._v("“最先适应”分配算法\n"),i("ul",[i("li",[_._v("顺序查找空闲分区表")]),_._v(" "),i("li",[_._v("缺点：经过若干次作业的装入和撤离后，可能会产生碎片（把较大的内存空间分配成若干个小的不连续的空闲分区，不能满足再次分配的需要），降低空间利用率")])])]),_._v(" "),i("li",[_._v("“最优适应”分配算法\n"),i("ul",[i("li",[_._v("选择一个满足作业地址空间要求的最小空闲分区")]),_._v(" "),i("li",[_._v("空闲分区按其长度以递增顺序登记在空闲分区表中")]),_._v(" "),i("li",[_._v("缺点：每次分配后分割的剩余空间总是最小的，形成的碎片非常零散，难以再次分配，从而影响内存空间的利用率")])])]),_._v(" "),i("li",[_._v("“最坏适应”算法（与最优适应算法相反）\n"),i("ul",[i("li",[_._v("每次总选择满足作业要求的最大空闲分区进行分割")]),_._v(" "),i("li",[_._v("对中小型作业是有利的")]),_._v(" "),i("li",[_._v("空闲分区按其长度以递减顺序登记在空间分区表中")])])])]),_._v(" "),i("h4",{attrs:{id:"_1-2-4-可重定位分配-紧凑功能"}},[_._v("1.2.4 可重定位分配-紧凑功能")]),_._v(" "),i("p",[_._v("程序中必要部分的代码和数据常驻内存，不常用的在其他程序模块中，平时存放在外存（覆盖文件），需要用到的时候才装入内存，不存在调用关系的模块不必同时装入到内存，可以相互覆盖，即不同时用的模块可共用一个分区")]),_._v(" "),i("h5",{attrs:{id:"覆盖"}},[_._v("覆盖")]),_._v(" "),i("ul",[i("li",[i("p",[_._v("覆盖：可以相互覆盖的程序段")])]),_._v(" "),i("li",[i("p",[_._v("覆盖区：可共享的内存区")])]),_._v(" "),i("li",[i("p",[_._v("优点：打破了一个作业全部信息装入内存后才能运行的限制，解决了小内存大作业的矛盾")])]),_._v(" "),i("li",[i("p",[_._v("缺点：必须划分程序模块和确定程序模块之间的覆盖关系，增加编程的复杂度")])]),_._v(" "),i("li",[i("p",[_._v("从外存装入覆盖文件，是以时间延长来换取空间节省")])])]),_._v(" "),i("h5",{attrs:{id:"交换"}},[_._v("交换")]),_._v(" "),i("p",[_._v("交换技术：把内存中暂时不能运行的进程或暂时不适用的程序和数据换出到外存，把已具备运行条件的进程或进程所需要的程序和数据换入内存")]),_._v(" "),i("h5",{attrs:{id:"覆盖和交换的区别"}},[_._v("覆盖和交换的区别")]),_._v(" "),i("ul",[i("li",[_._v("交换技术是在进程或作业之间进行")]),_._v(" "),i("li",[_._v("覆盖技术是在同一个作业或进程内进行")])]),_._v(" "),i("p",[i("a",{attrs:{href:"https://www.pianshen.com/article/4776786810/",target:"_blank",rel:"noopener noreferrer"}},[_._v("参考来源"),i("OutboundLink")],1)]),_._v(" "),i("h3",{attrs:{id:"_1-3-离散存储"}},[_._v("1.3 离散存储")]),_._v(" "),i("p",[_._v("在连续分配方式中，内存分配之后会产生大量的“碎片”，虽然在可重定位分区分配方式中引入了“紧凑”的思想，但是会花费很多开销。 如果可以将一个进程离散的装入到许多不同的分区中，就没有那些麻烦了，于是离散分配方式的思想就产生了。")]),_._v(" "),i("h4",{attrs:{id:"_1-3-1-分页存储管理"}},[_._v("1.3.1 分页存储管理")]),_._v(" "),i("p",[_._v("离散分配方式的基本单位是页，就称为分页存储管理方式。")]),_._v(" "),i("p",[_._v("分页存储方式引出了三个概念，一个叫页面（在页表中对应页号），一个叫物理块（在页表中对应块号），一个叫页表。")]),_._v(" "),i("ul",[i("li",[_._v("页面：指的是将程序按逻辑地址空间分成若干个页，每个页的大小是相同的，给他们编号得到页号。")]),_._v(" "),i("li",[_._v("物理块：指的是将程序的实际物理地址空间分成若干个块，给他们编号得到块号。")]),_._v(" "),i("li",[_._v("页表：系统为每一个进程建立了一张页面和物理块的映射表。")])]),_._v(" "),i("p",[_._v("通过将逻辑地址和物理地址分开划分，然后设置映射建立联系的方式，我们可以实现程序在内存上的离散存储。")]),_._v(" "),i("p",[_._v("劣势在于，页面固定的情况下，总会出现程序填不满完整的一个页面的情况，那样也会出现“碎片”现象，我们称之为“页内碎片”，同时，增加映射关系也会增加我们的访问成本。")]),_._v(" "),i("img",{staticStyle:{width:"100%"},attrs:{src:t(492),alt:"drawing"}}),_._v(" "),i("h4",{attrs:{id:"_1-3-2-分段存储管理方式"}},[_._v("1.3.2 分段存储管理方式")]),_._v(" "),i("p",[_._v("为什么要引入分段存储管理方式，毕竟分页管理已经可以做到将数据离散存放。引入分段存储管理的原因，一方面是将程序分成若干个程序段后，可以使程序更直观；另一方面，分段实现和满足了信息共享，信息保护，信息动态增长等需要。简单来说就是方便编程。")]),_._v(" "),i("p",[_._v("段存储管理方式中，作业的地址空间被划分为若干个段，每个段定义了一组逻辑信息。系统为每一个分段分配一个连续的分区。同时引入段表的概念，段表表示了逻辑段和物理地址的映射。")]),_._v(" "),i("h4",{attrs:{id:"_1-3-3-段页式存储管理方式"}},[_._v("1.3.3 段页式存储管理方式")]),_._v(" "),i("p",[_._v("段页式存储管理其实就是把分段和分页原理结合，即先将用户程序分成若干个段，然后再将每个段分为若干个页，并为每一个段赋予一个段名。")])])}),[],!1,null,null,null);v.default=l.exports}}]);