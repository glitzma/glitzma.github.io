(window.webpackJsonp=window.webpackJsonp||[]).push([[96],{314:function(v,_,e){"use strict";e.r(_);var t=e(2),a=Object(t.a)({},function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h2",{attrs:{id:"总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结","aria-hidden":"true"}},[v._v("#")]),v._v(" 总结")]),v._v(" "),e("h3",{attrs:{id:"最佳实践可以避免错误，同时大幅度提升应用的性能。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#最佳实践可以避免错误，同时大幅度提升应用的性能。","aria-hidden":"true"}},[v._v("#")]),v._v(" 最佳实践可以避免错误，同时大幅度提升应用的性能。")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("为列表渲染设置属性key")]),v._v(" "),e("p",[v._v("key这个属性主要用在Vue.js的虚拟DOM算法中，在对比新旧虚拟节点时辨识虚拟节点。如果这个查找过程中设置了属性key，则查找速度会快很多")])]),v._v(" "),e("li",[e("p",[v._v("在v-if/v-if-else/v-else中使用key")]),v._v(" "),e("p",[v._v("v-if在编译后")]),v._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[v._v("(has)\n   ? _c('li',[_v(\"if\")])\n   : _c('li',[_v(\"else\")])\n")])])]),e("p",[v._v("当相同类型的元素之间切换时，会修补已存在的元素，而不是将旧的元素移除。如果本不相同的元素被识别为相同，则会出现意料之外的副作用")])]),v._v(" "),e("li",[e("p",[v._v("编程式导航路由切换组件不变,"),e("code",[v._v("<router-view></router-view>")]),v._v("组件添加属性key会重新创建组件")]),v._v(" "),e("p",[v._v("同一路由不同参数地址，组件生命周期钩子不会重新触发，可添加导航守卫解决beforeRouteUpdate")])]),v._v(" "),e("li",[e("p",[v._v("避免v-if和v-for一起使用")]),v._v(" "),e("blockquote",[e("p",[v._v('官方解释：\n当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。这个类似 Vue 1.x 的 track-by="$index" 。\n建议尽可能在使用 v-for 时提供 key，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。\n当它们处于同一节点，v-for 的优先级比 v-if 更高，这意味着 v-if 将分别重复运行于每个 v-for 循环中。当你想为仅有的一些项渲染节点时，这种优先级的机制会十分有用')])])]),v._v(" "),e("li",[e("p",[v._v("为组件样式设置作用域")]),v._v(" "),e("p",[v._v("只有顶级组件和布局中样式可以是全局的，其他所有组件都应该是有作用域的（只在单文件组件下生效）。")])]),v._v(" "),e("li",[e("p",[v._v("避免在scoped中使用元素选择器")])]),v._v(" "),e("li",[e("p",[v._v("避免隐性的父子组件通信")]),v._v(" "),e("p",[v._v("prop向下传递，事件向上传递 ，遵循这一约定，会让你的组件更容易理解")])])]),v._v(" "),e("h3",{attrs:{id:"风格规范可以避免小纠结与反模式，同时绝大多数工程中可改善可读性和开发体验"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#风格规范可以避免小纠结与反模式，同时绝大多数工程中可改善可读性和开发体验","aria-hidden":"true"}},[v._v("#")]),v._v(" 风格规范可以避免小纠结与反模式，同时绝大多数工程中可改善可读性和开发体验")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("单文件组件命名")]),v._v(" "),e("p",[v._v("单文件命名应该始终以首字母大写（PascalCase），或者始终是横线连接（kebab-case）")])]),v._v(" "),e("li",[e("p",[v._v("组件命名")]),v._v(" "),e("p",[v._v("以一个特定的前缀开头，比如Base、App或V。")]),v._v(" "),e("p",[v._v("这样当组件全部列在一起时更容易识别")])]),v._v(" "),e("li",[e("p",[v._v("自闭合组件")]),v._v(" "),e("p",[v._v("在单文件组件、字符串模板和JSX中，没有内容的组件应该是自闭合的，但在DOM模板中不要这样做。")])]),v._v(" "),e("li",[e("p",[v._v("prop名的大小写")]),v._v(" "),e("p",[v._v("声明prop时，应该使用驼峰式命名规则，而在模板和JSX中应该使用横线连接")])]),v._v(" "),e("li",[e("p",[v._v("多个特性的元素")]),v._v(" "),e("p",[v._v("用多行分隔对象的多个属性，更易读")])]),v._v(" "),e("li",[e("p",[v._v("模板中简单的表达式")]),v._v(" "),e("p",[v._v("组件模板应该只包含简单的表达式，复杂 的表达式则应该重构为计算属性或方法")])]),v._v(" "),e("li",[e("p",[v._v("简单的计算属性")]),v._v(" "),e("p",[v._v("较小的、专注的计算属性减少了信息使用时的假设性限制，所以需求变更时也不需要那么多重构。")])]),v._v(" "),e("li",[e("p",[v._v("指令缩写")]),v._v(" "),e("p",[v._v("指令缩写要保持统一(用v-bind: @表示v-on)")])]),v._v(" "),e("li",[e("p",[v._v("良好的代码顺序")]),v._v(" "),e("p",[e("code",[v._v("<script><\/script> 、 <template></template>、 <style></style>")])]),v._v(" "),e("p",[v._v("其中"),e("code",[v._v("<style>")]),v._v(" 顺序要放在最后， 另外两个标签至少要有一个")])])]),v._v(" "),e("h3",{attrs:{id:"结语"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#结语","aria-hidden":"true"}},[v._v("#")]),v._v(" 结语")]),v._v(" "),e("p",[v._v("遵循这些规范能够在绝大多数工程中改善可读性和开发体验.")]),v._v(" "),e("p",[v._v("[参考《深入浅出Vue.js]")])])},[],!1,null,null,null);_.default=a.exports}}]);