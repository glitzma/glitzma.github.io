(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{343:function(e,t,a){"use strict";a.r(t);var n=a(2),r=Object(n.a)({},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"react学习"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react学习","aria-hidden":"true"}},[e._v("#")]),e._v(" react学习")]),e._v(" "),a("p",[e._v("react对象")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("eleObj ={\n    tyle:'div',\n    props:{\n        id:1,\n        children:['hello']\n    }\n};\nrender(eleObj,document.querySelector('#root'));\n\n相当于\n\nlet _ele2 = React.createElement('div',{id:1,className:'red',['hello']});\nconsole.log(_ele2);\n")])])]),a("h2",{attrs:{id:"jsx中表达式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jsx中表达式","aria-hidden":"true"}},[e._v("#")]),e._v(" jsx中表达式")]),e._v(" "),a("p",[e._v("在jsx中,所有的表达式都放在{}中,可以放任何 JavaScript 的代码，包括变量、表达式计算、函数执行等等,会将表达式运行的结果展现到页面内")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("循环列表\n将数组以列表的形式展现到页面内,jsx中可以嵌套表达式，表达式中也可以嵌套jsx语法。遇到HTML标签(以 < 开头)，就用HTML规则解析，遇到代码块(以 { 开头)，就用JavaScript规则解析")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("let arr = ['苹果','香蕉','橘子'];\nReactDOM.render(<div>\n    {arr.map((fruit,index)=>{\n        return <li>{fruit}</li>\n    })}\n</div>,document.querySelector('#root'));\n")])])]),a("p",[e._v("此时react会抛出警告Each child in an array or iterator should have a unique “key” prop.在使用循环是要给每个JSX元素增加key属性")])]),e._v(" "),a("li",[a("p",[e._v("给每个JSX元素增加key属性")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("<li key={index}>{fruit}</li>\n")])])])]),e._v(" "),a("li",[a("p",[e._v("渲染空元素")]),e._v(" "),a("p",[e._v("当数组项为香蕉我希望此项不进行显示")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("ReactDOM.render(<div>\n    {arr.map((fruit,index)=>{\n        return fruit==='香蕉'?null:<li key={index}>{fruit}</li>\n    })}\n</div>,document.querySelector('#root'));\n")])])]),a("p",[e._v("这个例子中说明了表达式中可以放置三元表达式，并且null也是一个合法元素")])]),e._v(" "),a("li",[a("p",[e._v("绑定样式")]),e._v(" "),a("p",[e._v("在JSX中绑定style样式与html的写法不同，JSX采用对象的方式绑定样式")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("ReactDOM.render(<div>\n    <span style={style}>我是红色</span>\n    {/*或者也可以直接写成*/}\n    <span style={{color:'red'}}>我是红色</span>\n</div>,document.querySelector('#root'));\n")])])]),a("p",[e._v("这里还要注意如果想在JSX中写注释，必须要采用{/**/}这样的方式,下一讲我们开始组件部分的学习")])])]),e._v(" "),a("h2",{attrs:{id:"组件的概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#组件的概念","aria-hidden":"true"}},[e._v("#")]),e._v(" 组件的概念")]),e._v(" "),a("p",[e._v("我们可以很直观的将一个复杂的页面分割成若干个独立组件,每个组件包含自己的逻辑和样式 再将这些独立组件组合完成一个复杂的页面。 这样既减少了逻辑复杂度，又实现了代码的重用")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("可组合：一个组件可以和其他的组件一起使用或者可以直接嵌套在另一个组件内部")])]),e._v(" "),a("li",[a("p",[e._v("可重用：每个组件都是具有独立功能的，它可以被使用在多个场景中")])]),e._v(" "),a("li",[a("p",[e._v("可维护：每个小的组件仅仅包含自身的逻辑，更容易被理解和维护")])]),e._v(" "),a("li",[a("p",[e._v("组件")]),e._v(" "),a("p",[e._v("前面我们介绍了JSX元素，JSX元素是构建react的基本单位,JSX元素要注意必须首字母小写，而且属性必须存在。接下来我们就来介绍组件,组件的定义是基于JSX元素，定义后可以像JSX元素一样的使用,组件的特点有:")]),e._v(" "),a("ul",[a("li",[e._v("首字母必须大写,目的是为了和JSX元素进行区分")]),e._v(" "),a("li",[e._v("组件定义后可以像JSX元素一样进行使用")]),e._v(" "),a("li",[e._v("每个组件必须返回唯一的顶级JSX元素")]),e._v(" "),a("li",[e._v("可以通过render方法将组件渲染成真实DOM")])])]),e._v(" "),a("li",[a("p",[e._v("组件的两种定义方式")]),e._v(" "),a("p",[e._v("第一种方式是函数声明\n第二种方式是类声明")])]),e._v(" "),a("li",[a("p",[e._v("函数声明")]),e._v(" "),a("p",[e._v("通过函数声明的组件都是静态组件(无状态组件),函数的参数是调用组件时传递的属性,会将属性转换为对象,赋予给函数的第一次参数")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("import React from 'react';\nimport {render} from 'react-dom';\nlet Message = (props) =>{\n    return (<h1 style={props.style}>欢迎！</h1>)\n}\nrender(<Message style={{color:'red'}}/>,document.querySelector('#root'));\n")])])]),a("p",[e._v("这里要注意此时我们直接使用的render,是通过react-dom中解构出来的,函数的返回值必须只能包含一个顶级JSX元素(JSX elements must be wrapped in an enclosing tag),如果有换行需要用()进行包裹，将整体作为返回内容,下一节我们来介绍组件的另一种声明方式")])])]),e._v(" "),a("h2",{attrs:{id:"通过类声明组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#通过类声明组件","aria-hidden":"true"}},[e._v("#")]),e._v(" 通过类声明组件")]),e._v(" "),a("p",[e._v("函数声明组件的方式,通过函数声明是静态的(无状态),那么类声明和函数声明的区别就在于通过类声明的组件是有状态的。")]),e._v(" "),a("ul",[a("li",[e._v("时钟组件")])]),e._v(" "),a("p",[e._v("我们来对比下两种组件的声明方式，来实现一个会动的时钟")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("let Clock = (props) =>{\n    return (\n        <h1>{props.time}</h1>\n    )\n};\nsetInterval(()=>{\n    render(<Clock time={new Date().toLocaleString()}/>,document.querySelector('#root'));\n},1000)\n")])])]),a("p",[e._v("通过函数声明的方式我们发现时间并不是由组件自己决定的,而是我们每隔1s手动传入,这并不符合我们的预期,我们需要创造的是本身就可以动的时钟。此时我们只能通过类声明的方式")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("class Clock extends React.Component{\n    constructor(){\n        super();\n        this.state = {time:new Date().toLocaleString()}\n    }\n    render(){\n        return (\n            <h1>{this.state.time}</h1>\n        )\n    }\n}\nrender(<Clock />,document.querySelector('#root'));\n")])])]),a("p",[e._v("我们通过类的方式声明了时钟组件,这里我们将时间存到了组件内部的状态,好处是时间由组件内部决定，但是时钟依然不会自己动,我们需要借助组件的一个声明周期(钩子方法),componentDidMount(真实的dom已经挂载到页面中)在内部更改组件的状态重新触发组件的render")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("class Clock extends React.Component{\n    constructor(){\n        super();\n        this.state = {time:new Date().toLocaleString()}\n    }\n    render(){\n        return (<h1>{this.state.time}</h1>)\n    }\n+    componentDidMount(){\n+        setInterval(()=>{\n+            this.setState({\n+                time:new Date().toLocaleString()\n+            })\n+        },1000)\n+    }}\nrender(<Clock/>,document.querySelector('#root'));\n")])])]),a("p",[e._v("现在会动的时钟就实现了,时间由组件的内部决定。这里要注意调用setState不是将所有dom重新渲染，react内部会做domDiff,将需要变化的内容进行更新,简单的总结一下，状态的作用是，可以存放组件内部变化的值，只由组件内部声明，内部改变。下一节我们来介绍组件的属性")]),e._v(" "),a("h2",{attrs:{id:"组件的属性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#组件的属性","aria-hidden":"true"}},[e._v("#")]),e._v(" 组件的属性")]),e._v(" "),a("p",[e._v("在上几小节中,其实一直都有用到属性,与状态不同的是,属性是在使用组件时传递的而非组件内部控制。")]),e._v(" "),a("ul",[a("li",[e._v("属性传递")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("class Person extends React.Component{\n    render(){\n        let {name,age} = this.props;\n        return (\n            <div>\n                我的名字是{name},今年{age}岁了\n            </div>\n        )\n    }\n}\nrender(<Person name='bbb' age=\"9\"/>,document.querySelector('#root'));\n")])])]),a("p",[e._v("通过age=”9”方式传递参数类型都是字符串,如果要传递成数组字需要写成 age={9},这样传递的内容会作为对象挂载到组件的props属性上")]),e._v(" "),a("ul",[a("li",[e._v("属性校验")])]),e._v(" "),a("p",[e._v("我们可以任意的像组件中传入数据,同样在组件内部也可以对这些属性的类型、是否必填做出校验,需要用到一个模块prop-types")]),e._v(" "),a("p",[e._v("安装prop-types")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("$ npm install prop-types\n校验\n\nimport PropTypes from 'prop-types'\nclass Person extends React.Component{\n+   static propTypes = {\n+     age:PropTypes.number,\n+     name:PropTypes.string.isRequired\n+   };\n    render(){\n        let {name,age} = this.props;\n        return (\n            <div>\n                我的名字是{name},今年{age}岁了\n            </div>\n        )\n    }\n}\nrender(<Person name='bbb' age=\"9\"/>,document.querySelector('#root'));\n")])])]),a("p",[e._v("此时控制台会打印出 Failed prop type: Invalid prop age of type string supplied to Person, expected number,需要传入的是number类型")]),e._v(" "),a("ul",[a("li",[e._v("默认属性")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("import PropTypes from 'prop-types'\nclass Person extends React.Component{\n    static propTypes = {\n      age:PropTypes.number,\n      name:PropTypes.string.isRequired\n    };\n+   static defaultProps = {\n+       name:'hello,aaaaaaaaaaa'\n+   };\n    render(){\n        let {name,age} = this.props;\n        return (\n            <div>\n                我的名字是{name},今年{age}岁了\n            </div>\n        )\n    }\n}\n+ render(<Person age=\"9\"/>,document.querySelector('#root'));\n- render(<Person name=\"aaaaa\" age=\"9\"/>,document.querySelector('#root'));\n")])])]),a("p",[e._v("当不传入name属性时,name的值会默认采用defaultProps中所定义的默认值")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("绑定函数")]),e._v(" "),a("p",[e._v("说到这里,我们要来强调一下！属性是只读的,不能在组件中更改属性的值,但是我们可以更改状态因为状态是属于组件内部的\n"),a("code",[e._v("constructor(){ super(); this.state = {heart:true} } handler(){ this.setState({ heart:!this.state.heart }) } render(){ let {name,age} = this.props; let heart = this.state.heart?'开心':'不开心'; return ( <div> 我的名字是{name},今年{age}岁了 <p>{heart}</p> <div onClick={this.handler.bind(this)}>变心</div> </div> ) }")]),e._v("\n这里呢，我们通过给元素绑定事件的方式来更改状态，要注意的是所有事件事件名开头都要大写,通过这种方式绑定事件都要指定this，否则函数中的this是undefined")])]),e._v(" "),a("li",[a("p",[e._v("绑定this的方式")]),e._v(" "),a("ul",[a("li",[e._v("在构造函数中绑定"),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("constructor(){\n    super();\n    this.state = {heart:true}\n    this.handler = this.handler.bind(this)\n}\nreturn (\n    <div>\n        <div onClick={this.handler}>变心</div>\n    </div>\n)\n")])])])]),e._v(" "),a("li",[e._v("在调用事件时直接绑定"),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("return (\n    <div>\n        <div onClick={this.handler.bind(this)}>变心</div>\n    </div>\n)\n")])])])]),e._v(" "),a("li",[e._v("采用箭头函数的方式"),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("return (\n    <div>\n        <div onClick={()=>{this.handler()}}>变心</div>\n    </div>\n)\n")])])])]),e._v(" "),a("li",[e._v("es7语法绑定this"),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("handler=()=>{\n        this.setState({\n            heart:!this.state.heart\n        })\n}\n")])])]),e._v("以上几种方式都能解决this指向问题，本节我们介绍了组件中的属性和状态已经组件中绑定事件，下一节我们来介绍一下受控组件")])])])])])},[],!1,null,null,null);t.default=r.exports}}]);